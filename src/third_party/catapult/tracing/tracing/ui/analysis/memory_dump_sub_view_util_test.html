<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/units/units.html">
<link rel="import"
    href="/tracing/ui/analysis/memory_dump_sub_view_test_utils.html">
<link rel="import" href="/tracing/ui/analysis/memory_dump_sub_view_util.html">
<link rel="import" href="/tracing/ui/base/table.html">
<link rel="import" href="/tracing/model/attribute.html">

<script>
'use strict';

tr.b.unittest.testSuite(function() {
  var TitleColumn = tr.ui.analysis.TitleColumn;
  var MemoryColumn = tr.ui.analysis.MemoryColumn;
  var AggregationMode = MemoryColumn.AggregationMode;
  var ScalarMemoryColumn = tr.ui.analysis.ScalarMemoryColumn;
  var MemoryCell = tr.ui.analysis.MemoryCell;
  var fieldGetter = tr.ui.analysis.fieldGetter;
  var expandTableRowsRecursively = tr.ui.analysis.expandTableRowsRecursively;
  var aggregateTableRowCells = tr.ui.analysis.aggregateTableRowCells;
  var aggregateTableRowCellsRecursively =
      tr.ui.analysis.aggregateTableRowCellsRecursively;
  var StringAttribute = tr.model.StringAttribute;
  var ScalarAttribute = tr.model.ScalarAttribute;
  var UnknownAttribute = tr.model.UnknownAttribute;
  var AttributeInfo = tr.model.AttributeInfo;
  var AttributeInfoType = tr.model.AttributeInfoType;
  var checkSizeAttributes = tr.ui.analysis.checkSizeAttributes;
  var checkAttributes = tr.ui.analysis.checkAttributes;
  var createCells = tr.ui.analysis.createCells;
  var addAttributeIfDefined = tr.ui.analysis.addAttributeIfDefined;

  function checkPercent(string, expectedPercent) {
    assert.equal(Number(string.slice(0, -1)), expectedPercent);
    assert.equal(string.slice(-1), '%');
  }

  function checkMemoryColumnValueFormat(test, column, attrValues,
      expectedTextContent, opt_expectedColor) {
    var value = column.formatMultipleAttributeValues(
        buildStringCell(column.unit, attrValues).attrs);
    if (expectedTextContent === undefined) {
      assert.strictEqual(value, '');
      assert.isUndefined(opt_expectedColor);  // Test sanity check.
      return;
    }

    var node = tr.ui.b.asHTMLOrTextNode(value);
    var spanEl = document.createElement('span');
    spanEl.appendChild(node);
    test.addHTMLOutput(spanEl);

    assert.strictEqual(node.textContent, expectedTextContent);
    if (opt_expectedColor === undefined)
      assert.notInstanceOf(node, HTMLElement);
    else
      assert.strictEqual(node.style.color, opt_expectedColor);
  }

  function checkCompareAttributesEqual(column, attrValuesA, attrValuesB) {
    var attrsA = buildStringCell(column.unit, attrValuesA).attrs;
    var attrsB = buildStringCell(column.unit, attrValuesB).attrs;
    assert.strictEqual(column.compareAttributes(attrsA, attrsB), 0);
  }

  function checkCompareAttributesLess(column, attrValuesA, attrValuesB) {
    var attrsA = buildStringCell(column.unit, attrValuesA).attrs;
    var attrsB = buildStringCell(column.unit, attrValuesB).attrs;
    assert.isBelow(column.compareAttributes(attrsA, attrsB), 0);
    assert.isAbove(column.compareAttributes(attrsB, attrsA), 0);
  }

  function checkScalarMemoryColumnValueFormat(test, column, attrValues,
      expectedValue, expectedUnits, expectedIsDelta, opt_expectedColor) {
    var value = column.formatMultipleAttributeValues(
        buildScalarCell(column.unit, attrValues).attrs);
    if (expectedValue === undefined) {
      assert.equal(value, '');
      assert.isUndefined(expectedUnits);  // Test sanity check.
      assert.isUndefined(expectedIsDelta);  // Test sanity check.
      assert.isUndefined(opt_expectedColor);  // Test sanity check.
      return;
    }

    test.addHTMLOutput(value);
    var scalarSpan;
    if (opt_expectedColor === undefined) {
      scalarSpan = value;
    } else {
      assert.lengthOf(value.childNodes, 1);
      assert.equal(value.style.color, opt_expectedColor);
      scalarSpan = value.childNodes[0];
    }
    assert.equal(scalarSpan.tagName, 'TR-UI-U-SCALAR-SPAN');
    assert.equal(scalarSpan.value, expectedValue);
    assert.equal(scalarSpan.unit, expectedUnits);
    assert.equal(scalarSpan.isDelta, expectedIsDelta);
  }

  function buildStringCell(units, values) {
    return new MemoryCell(values.map(function(value) {
      if (value === undefined)
        return undefined;
      return new StringAttribute(units, value);
    }));
  }

  function buildScalarCell(units, values) {
    return new MemoryCell(values.map(function(value) {
      if (value === undefined)
        return undefined;
      return new ScalarAttribute(units, value);
    }));
  }

  function buildTestRows() {
    return [
      {
        title: 'Row 1',
        attributes: {
          'cpu_temperature': buildStringCell('C',
              ['below zero', 'absolute zero'])
        },
        subRows: [
          {
            title: 'Row 1A',
            attributes: {
              'page_size': buildScalarCell('bytes', [1024, 1025])
            }
          },
          {
            title: 'Row 1B',
            attributes: {
              'page_size': buildScalarCell('bytes', [512, 513]),
              'mixed': buildStringCell('ms', ['0.01', '0.10']),
              'mixed2': new MemoryCell([
                new ScalarAttribute('GeV', 2.43e18),
                new ScalarAttribute('MWh', 0.5433)
              ])
            }
          }
        ]
      },
      {
        title: 'Row 2',
        attributes: {
          'cpu_temperature': undefined,
          'mixed': buildScalarCell('ms', [0.99, 0.999])
        }
      }
    ];
  }

  function checkMemoryColumn(column, expectedName, expectedTitle, expectedUnits,
      expectedAggregationMode, testRow, expectedCell, expectedType) {
    assert.equal(column.name, expectedName);
    if (typeof expectedTitle === 'function')
      expectedTitle(column.title);
    else
      assert.equal(column.title, expectedTitle);
    assert.strictEqual(column.units, expectedUnits);
    assert.strictEqual(column.aggregationMode, expectedAggregationMode);
    assert.strictEqual(column.cell(testRow), expectedCell);
    assert.instanceOf(column, expectedType);
  }

  test('checkTitleColumn_value', function() {
    var column = new TitleColumn('column_title');
    assert.equal(column.title, 'column_title');
    assert.isFalse(column.supportsCellSelection);

    var row = {title: 'undefined', defined: undefined};
    assert.equal(column.formatTitle(row), 'undefined');
    assert.equal(column.value(row), 'undefined');

    var row = {title: 'constant', defined: [true, true, true, true]};
    assert.equal(column.formatTitle(row), 'constant');
    assert.equal(column.value(row), 'constant');

    var row = {title: 'added', defined: [false, false, false, true]};
    assert.equal(column.formatTitle(row), 'added');
    var value = column.value(row);
    assert.equal(value.textContent, '+++\u00A0added');
    assert.equal(value.style.color, 'red');

    var row = {title: 'removed', defined: [true, true, false, false]};
    assert.equal(column.formatTitle(row), 'removed');
    var value = column.value(row);
    assert.equal(value.textContent, '---\u00A0removed');
    assert.equal(value.style.color, 'green');

    var row = {title: 'flaky', defined: [true, false, true, true]};
    assert.equal(column.formatTitle(row), 'flaky');
    var value = column.value(row);
    assert.equal(value.textContent, 'flaky');
    assert.equal(value.style.color, 'purple');

    var row = {title: 'added-flaky', defined: [false, true, false, true]};
    assert.equal(column.formatTitle(row), 'added-flaky');
    var value = column.value(row);
    assert.equal(value.textContent, '+++\u00A0added-flaky');
    assert.equal(value.style.color, 'purple');

    var row = {title: 'removed-flaky', defined: [true, false, true, false]};
    assert.equal(column.formatTitle(row), 'removed-flaky');
    var value = column.value(row);
    assert.equal(value.textContent, '---\u00A0removed-flaky');
    assert.equal(value.style.color, 'purple');
  });

  test('checkTitleColumn_cmp', function() {
    var column = new TitleColumn('column_title');

    assert.isBelow(column.cmp({title: 'a'}, {title: 'b'}), 0);
    assert.equal(column.cmp({title: 'cc'}, {title: 'cc'}), 0);
    assert.isAbove(column.cmp({title: '10'}, {title: '2'}), 0);
  });

  test('checkMemoryColumn_fromRows_defaultColumnConstructorRules', function() {
    var rows = buildTestRows();
    var columns =
        MemoryColumn.fromRows(rows, 'attributes', AggregationMode.DIFF);
    assert.lengthOf(columns, 4);

    var cpuTemperatureColumn = columns[0];
    checkMemoryColumn(cpuTemperatureColumn, 'cpu_temperature',
        'cpu_temperature', 'C', AggregationMode.DIFF,
        {attributes: {cpu_temperature: 42}}, 42, MemoryColumn);

    var pageSizeColumn = columns[1];
    checkMemoryColumn(pageSizeColumn, 'page_size', 'page_size', 'bytes',
        AggregationMode.DIFF, {attributes: {page_size: 'large'}}, 'large',
        ScalarMemoryColumn);

    var mixedColumn = columns[2];
    checkMemoryColumn(mixedColumn, 'mixed', 'mixed', undefined /* unitless */,
        AggregationMode.DIFF, {attributes: {mixed: 89}}, 89, MemoryColumn);

    var mixed2Column = columns[3];
    checkMemoryColumn(mixed2Column, 'mixed2', 'mixed2',
        undefined /* unitless */, AggregationMode.DIFF,
        {attributes: {mixed2: 'invalid'}}, 'invalid', MemoryColumn);
  });

  test('checkMemoryColumn_fromRows_customColumnConstructorRules', function() {
    function MockColumn1() {
      MemoryColumn.apply(this, arguments);
    }
    MockColumn1.prototype = {
      __proto__: MemoryColumn.prototype,
      get title() { return 'MockColumn1'; }
    };

    function MockColumn2() {
      MemoryColumn.apply(this, arguments);
    }
    MockColumn2.prototype = {
      __proto__: MemoryColumn.prototype,
      get title() { return 'MockColumn2'; }
    };

    var rules = [
      {
        condition: /size/
        // columnConstructor intentionally undefined.
      },
      {
        condition: 'cpu_temperature',
        columnConstructor: MockColumn1
      },
      {
        condition: 'unmatched',
        get columnConstructor() {
          throw new Error('The constructor should never be retrieved');
        }
      },
      {
        condition: /d$/,
        columnConstructor: MockColumn2
      }
    ];

    var rows = buildTestRows();
    var columns = MemoryColumn.fromRows(rows, 'attributes', AggregationMode.MAX,
        rules);
    assert.lengthOf(columns, 4);

    var cpuTemperatureColumn = columns[0];
    checkMemoryColumn(cpuTemperatureColumn, 'cpu_temperature', 'MockColumn1',
        'C', AggregationMode.MAX, {attributes: {cpu_temperature: 42}}, 42,
        MockColumn1);

    var pageSizeColumn = columns[1];
    checkMemoryColumn(pageSizeColumn, 'page_size', 'page_size', 'bytes',
        AggregationMode.MAX, {attributes: {page_size: 'large'}}, 'large',
        ScalarMemoryColumn);

    var mixedColumn = columns[2];
    checkMemoryColumn(mixedColumn, 'mixed', 'MockColumn2',
        undefined /* unitless */, AggregationMode.MAX,
        {attributes: {mixed: 89}}, 89, MockColumn2);

    var mixed2Column = columns[3];
    checkMemoryColumn(mixed2Column, 'mixed2', 'mixed2',
        undefined /* unitless */, AggregationMode.MAX,
        {attributes: {mixed2: 'invalid'}}, 'invalid', MemoryColumn);
  });

  test('checkMemoryColumn_constructorFromAttributeTraits', function() {
    // String attribute.
    assert.strictEqual(MemoryColumn.constructorFromAttributeTraits(
        {constructor: StringAttribute, units: 'Mbps'}), MemoryColumn);

    // Scalar attribute.
    assert.strictEqual(MemoryColumn.constructorFromAttributeTraits(
        {constructor: ScalarAttribute, units: 'bytes'}), ScalarMemoryColumn);

    // Unknown attribute.
    assert.strictEqual(MemoryColumn.constructorFromAttributeTraits(
        {constructor: UnknownAttribute, units: undefined}), MemoryColumn);
  });

  test('checkMemoryColumn_spaceEqually', function() {
    // Zero columns.
    var columns = [];
    MemoryColumn.spaceEqually(columns);

    // One column.
    var columns = [
      {
        title: 'First Column',
        value: function(row) { return row.firstData; }
      }
    ];
    MemoryColumn.spaceEqually(columns);
    checkPercent(columns[0].width, 100);

    // Two columns.
    var columns = [
      {
        title: 'First Column',
        value: function(row) { return row.firstData; }
      },
      {
        title: 'Second Column',
        value: function(row) { return row.firstData; }
      }
    ];
    MemoryColumn.spaceEqually(columns);
    checkPercent(columns[0].width, 50);
    checkPercent(columns[1].width, 50);
  });

  test('checkMemoryColumn_sortByImportance', function() {
    var columns = [
      new MemoryColumn('page_size', 'bytes', fieldGetter('pgsize')),
      new MemoryColumn('resident_size', 'bytes', fieldGetter('rss')),
      new MemoryColumn('object_count', 'objects', fieldGetter('objcount')),
      new MemoryColumn('proportional_size', 'bytes', fieldGetter('pss'))
    ];

    var rules = [
      {
        condition: 'page_size',
        importance: 8
      },
      {
        condition: /size/,
        importance: 10
      },
      {
        importance: 9
      }
    ];

    MemoryColumn.sortByImportance(columns, rules);

    assert.lengthOf(columns, 4);
    assert.equal(columns[0].name, 'proportional_size');
    assert.equal(columns[1].name, 'resident_size');
    assert.equal(columns[2].name, 'object_count');
    assert.equal(columns[3].name, 'page_size');
  });

  test('checkMemoryColumn_columnNamesToImportanceRules', function() {
    var columnNames = ['A', 'B', 'C'];
    var importanceRules =
        MemoryColumn.columnNamesToImportanceRules(columnNames);

    assert.lengthOf(importanceRules, 3);

    assert.equal(importanceRules[0].condition, 'A');
    assert.equal(importanceRules[0].importance, 3);
    assert.equal(importanceRules[1].condition, 'B');
    assert.equal(importanceRules[1].importance, 2);
    assert.equal(importanceRules[2].condition, 'C');
    assert.equal(importanceRules[2].importance, 1);
  });

  test('checkMemoryColumn_fields', function() {
    var c = new MemoryColumn('test_column', 'ms', fieldGetter('x'),
        AggregationMode.MAX);
    assert.equal(c.name, 'test_column');
    assert.equal(c.title, 'test_column');
    assert.equal(c.units, 'ms');
    assert.equal(c.cell({x: 95}), 95);
    assert.isUndefined(c.width);
    assert.isUndefined(c.color);
  });

  test('checkMemoryColumn_attrs', function() {
    var c = new MemoryColumn('test_column', 'ms', fieldGetter('x'),
        AggregationMode.MAX);

    // Undefined cell or attribute inside cell.
    assert.isUndefined(c.attrs({}));
    assert.isUndefined(c.attrs({x: new MemoryCell(undefined)}));

    // Defined attribute(s) inside cell.
    var attr1 = new ScalarAttribute('hPa', 1013.25);
    var attr2 = new ScalarAttribute('hPa', 1065);
    var row1 = {x: new MemoryCell([attr1])};
    var row2 = {x: new MemoryCell([attr1, attr2])};
    assert.deepEqual(c.attrs(row1), [attr1]);
    assert.deepEqual(c.attrs(row2), [attr1, attr2]);
  });

  test('checkMemoryColumn_hasAllRelevantAttrsUndefined', function() {
    // Single attribute.
    var c1 = new MemoryColumn('single_column', 'ms', fieldGetter('x'),
        undefined /* aggregation mode */);
    assert.isTrue(c1.hasAllRelevantAttrsUndefined([undefined]));
    assert.isFalse(c1.hasAllRelevantAttrsUndefined(
        [new ScalarAttribute('bytes', 16)]));

    // Multiple attributes, diff aggregation mode.
    var c2 = new MemoryColumn('diff_column', 'ms', fieldGetter('x'),
        AggregationMode.DIFF);
    assert.isTrue(c2.hasAllRelevantAttrsUndefined([undefined, undefined]));
    assert.isTrue(c2.hasAllRelevantAttrsUndefined(
        [undefined, undefined, undefined]));
    assert.isTrue(c2.hasAllRelevantAttrsUndefined(
        [undefined, new ScalarAttribute('bytes', 16), undefined]));
    assert.isFalse(c2.hasAllRelevantAttrsUndefined(
        [undefined, new ScalarAttribute('bytes', 32)]));
    assert.isFalse(c2.hasAllRelevantAttrsUndefined(
        [new ScalarAttribute('bytes', 32), undefined, undefined]));
    assert.isFalse(c2.hasAllRelevantAttrsUndefined([
        new ScalarAttribute('bytes', 16),
        undefined,
        new ScalarAttribute('bytes', 32)]));

    // Multiple attributes, max aggregation mode.
    var c3 = new MemoryColumn('max_column', 'ms', fieldGetter('x'),
        AggregationMode.MAX);
    assert.isTrue(c3.hasAllRelevantAttrsUndefined([undefined, undefined]));
    assert.isTrue(c3.hasAllRelevantAttrsUndefined(
        [undefined, undefined, undefined]));
    assert.isFalse(c3.hasAllRelevantAttrsUndefined(
        [undefined, new ScalarAttribute('bytes', 16), undefined]));
    assert.isFalse(c3.hasAllRelevantAttrsUndefined(
        [undefined, new ScalarAttribute('bytes', 32)]));
    assert.isFalse(c3.hasAllRelevantAttrsUndefined([
        new ScalarAttribute('bytes', 32),
        undefined,
        new ScalarAttribute('bytes', 16)]));
  });

  test('checkMemoryColumn_value_allAttrsUndefined', function() {
    var c1 = new MemoryColumn('no_color', 'ms', fieldGetter('x'),
        AggregationMode.MAX);
    var c2 = new MemoryColumn('color', 'ms', fieldGetter('x'),
        AggregationMode.DIFF);
    Object.defineProperty(c2, 'color', {
      get: function() {
        throw new Error('The color should never be retrieved');
      }
    });

    [c1, c2].forEach(function(c) {
      assert.equal(c.value({}), '');
      assert.equal(c.value({x: new MemoryCell(undefined)}), '');
      assert.equal(c.value({x: new MemoryCell([undefined])}), '');
      assert.equal(c.value({x: new MemoryCell([undefined, undefined])}), '');
    });

    // Diff should only take into account the first and last attribute value.
    assert.equal(c2.value({x: new MemoryCell(
        [undefined, new ScalarAttribute('bytes', 16), undefined])}), '');
  });

  test('checkMemoryColumn_value_singleAttribute', function() {
    var c1 = new MemoryColumn('no_color', 'ms', fieldGetter('x'),
        AggregationMode.MAX);
    var c2 = new MemoryColumn('color_string', 'ms', fieldGetter('x'),
        AggregationMode.MAX);
    c2.color = '#009999';
    var c3 = new MemoryColumn('color_function', 'ms', fieldGetter('x'),
        AggregationMode.MAX);
    c3.color = function(attrs) {
      return attrs[0].value > '0' ? 'green' : undefined;
    };

    // Without infos.
    var row = {x: buildScalarCell('ms', [123])};
    var value1 = c1.value(row);
    assert.equal(value1, '123');
    this.addHTMLOutput(tr.ui.b.createSpan({textContent: value1}));
    var value2 = c2.value(row);
    assert.equal(value2.textContent, '123');
    assert.equal(value2.style.color, 'rgb(0, 153, 153)');
    this.addHTMLOutput(value2);
    var value3 = c3.value(row);
    assert.equal(value3.textContent, '123');
    assert.equal(value3.style.color, 'green');
    this.addHTMLOutput(value3);

    var row = {x: buildScalarCell('ms', [-123])};
    var value1 = c1.value(row);
    assert.equal(value1, '-123');
    this.addHTMLOutput(tr.ui.b.createSpan({textContent: value1}));
    var value2 = c2.value(row);
    assert.equal(value2.textContent, '-123');
    assert.equal(value2.style.color, 'rgb(0, 153, 153)');
    this.addHTMLOutput(value2);
    var value3 = c3.value(row);
    assert.equal(value3, '-123');
    this.addHTMLOutput(tr.ui.b.createSpan({textContent: value3}));

    // With infos.
    var checkCellValue = function(value, expectedText, expectedColor) {
      assert.lengthOf(value.childNodes, 3);
      assert.equal(value.style.color, expectedColor);
      assert.equal(value.childNodes[0].textContent, expectedText);
      assert.equal(value.childNodes[1].textContent, String.fromCharCode(9888));
      assert.equal(value.childNodes[1].title, 'This value is too cool');
      assert.equal(value.childNodes[2].textContent, String.fromCharCode(9903));
      assert.equal(value.childNodes[2].title, 'Source: Test');
      this.addHTMLOutput(value);
    }.bind(this);

    var cell = buildStringCell('ms', ['couple']);
    cell.attrs[0].infos = [
      new AttributeInfo(AttributeInfoType.WARNING, 'This value is too cool'),
      new AttributeInfo(AttributeInfoType.LINK, 'Source: Test')
    ];
    checkCellValue(c1.value({x: cell}), 'couple', '');
    checkCellValue(c2.value({x: cell}), 'couple', 'rgb(0, 153, 153)');
    checkCellValue(c3.value({x: cell}), 'couple', 'green');

    var cell = buildStringCell('ms', ['-couple']);
    cell.attrs[0].infos = [
      new AttributeInfo(AttributeInfoType.WARNING, 'This value is too cool'),
      new AttributeInfo(AttributeInfoType.LINK, 'Source: Test')
    ];
    checkCellValue(c1.value({x: cell}), '-couple', '');
    checkCellValue(c2.value({x: cell}), '-couple', 'rgb(0, 153, 153)');
    checkCellValue(c3.value({x: cell}), '-couple', '');
  });

  test('checkMemoryColumn_value_multipleAttributes', function() {
    var c1 = new MemoryColumn('test_column1', 'ms', fieldGetter('x'),
        undefined /* aggregation mode */);
    var c2 = new MemoryColumn('test_column2', 'ms', fieldGetter('x'),
        AggregationMode.DIFF);
    c2.color = '#009999';
    var c3 = new MemoryColumn('test_column3', 'ms', fieldGetter('x'),
        AggregationMode.MAX);
    c3.color = function(attrs) {
      return attrs.length % 2 === 1 ? 'green' : undefined;
    };

    var cell = buildStringCell('ms', ['old', 'new']);
    var value1 = c1.value({x: cell});
    assert.equal(value1.style.color, '');
    assert.equal(value1.textContent, '(unsupported aggregation mode)');
    this.addHTMLOutput(value1);
    var value2 = c2.value({x: cell});
    assert.equal(value2.style.color, 'rgb(0, 153, 153)');
    assert.equal(value2.textContent, 'old \u2192 new');
    this.addHTMLOutput(value2);
    var value3 = c3.value({x: cell});
    assert.equal(value3, 'old');

    var cell = buildStringCell('ms', ['old', undefined, 'new']);
    var value1 = c1.value({x: cell});
    assert.equal(value1.style.color, '');
    assert.equal(value1.textContent, '(unsupported aggregation mode)');
    this.addHTMLOutput(value1);
    var value2 = c2.value({x: cell});
    assert.equal(value2.style.color, 'rgb(0, 153, 153)');
    assert.equal(value2.textContent, 'old \u2192 new');
    this.addHTMLOutput(value2);
    var value3 = c3.value({x: cell});
    assert.equal(value3.style.color, 'green');
    assert.equal(value3.textContent, 'old');
    this.addHTMLOutput(value3);
  });

  test('checkMemoryColumn_formatSingleAttributeValue', function() {
    var c = new MemoryColumn('test_column', 'ms', fieldGetter('x'),
        undefined /* aggregation mode */);

    assert.equal(c.formatSingleAttributeValue(
        new ScalarAttribute('bytes', 1024)), '1024');
    assert.equal(c.formatSingleAttributeValue(
        new StringAttribute('ms', '~10')), '~10');
  });

  test('checkMemoryColumn_formatMultipleAttributeValues_diff', function() {
    var c = new MemoryColumn('test_column', 'ms', fieldGetter('x'),
        AggregationMode.DIFF);

    // Added value.
    checkMemoryColumnValueFormat(this, c, [undefined, 'few'], '+few', 'red');
    checkMemoryColumnValueFormat(this, c, [undefined, 64, 32], '+32', 'red');

    // Removed value.
    checkMemoryColumnValueFormat(this, c, ['00', undefined], '-00', 'green');
    checkMemoryColumnValueFormat(this, c, [1, undefined, 2, undefined], '-1',
        'green');

    // Identical values.
    checkMemoryColumnValueFormat(this, c, ['Unchanged', 'Unchanged'],
        'Unchanged', undefined /* unchanged color (not an HTML element) */);
    checkMemoryColumnValueFormat(this, c, [16, 32, undefined, 64, 16], '16',
        undefined /* unchanged color (not an HTML element) */);

    // Different values.
    checkMemoryColumnValueFormat(this, c, ['A', 'C', undefined, 'C', 'B'],
        'A \u2192 B', 'darkorange');
    checkMemoryColumnValueFormat(this, c, [16, undefined, 64], '16 \u2192 64',
        'darkorange');
  });

  test('checkMemoryColumn_formatMultipleAttributeValues_max', function() {
    var c = new MemoryColumn('test_column', 'ms', fieldGetter('x'),
        AggregationMode.MAX);

    // Different values.
    checkMemoryColumnValueFormat(this, c, ['A', 'B', 'A'], 'B',
        undefined /* unchanged color (not an HTML element) */);
    checkMemoryColumnValueFormat(this, c, [16, 16, undefined, 17], '17',
        undefined /* unchanged color (not an HTML element) */);

    // Identical values.
    checkMemoryColumnValueFormat(this, c, ['X', 'X'], 'X',
        undefined /* unchanged color (not an HTML element) */);
    checkMemoryColumnValueFormat(this, c, [7, undefined, 7, undefined, 7], '7',
        undefined /* unchanged color (not an HTML element) */);
  });

  test('checkMemoryColumn_compareSingleAttributes', function() {
    var c = new MemoryColumn('test_column', 'ms', fieldGetter('x'),
        undefined /* aggregation mode */);

    assert.isBelow(c.compareSingleAttributes(new ScalarAttribute('bytes', 2),
        new ScalarAttribute('bytes', 10)), 0);
    assert.equal(c.compareSingleAttributes(new StringAttribute('', 'equal'),
        new StringAttribute('', 'equal')), 0);
    assert.isAbove(c.compareSingleAttributes(new StringAttribute('ms', '100'),
        new StringAttribute('ms', '99')), 0);
  });

  test('checkMemoryColumn_compareMultipleAttributes_diff', function() {
    var c = new MemoryColumn('test_column', 'ms', fieldGetter('x'),
        AggregationMode.DIFF);

    // One attribute was added.
    checkCompareAttributesLess(c, [-10, 10], [undefined, 5]);
    checkCompareAttributesLess(c,
        [-100, undefined, undefined], [undefined, 4, 5]);
    checkCompareAttributesLess(c,
        [1, 2, 3, 4], [undefined, 'x', undefined, 'y']);

    // Both attributes were added.
    checkCompareAttributesEqual(c,
        [undefined, 'C', undefined, 'A'], [undefined, 'B', 'D', 'A']);
    checkCompareAttributesLess(c, [undefined, 1], [undefined, 2]);
    checkCompareAttributesLess(c, [undefined, 6, 3], [undefined, 5, 4]);

    // One attribute was removed (neither was added).
    checkCompareAttributesLess(c, ['B', undefined], ['A', 'A']);
    checkCompareAttributesLess(c,
        [5, undefined, undefined], [undefined, -5, -10]);

    // Both attributes were removed (neither was added)
    checkCompareAttributesEqual(c, ['T', 'A', undefined, undefined],
        ['T', 'B', 'C', undefined]);
    checkCompareAttributesLess(c, [5, undefined], [4, undefined]);

    // Neither attribute was added or removed.
    checkCompareAttributesLess(c, ['BB', 'BB'], ['AA', 'CC']);
    checkCompareAttributesEqual(c, [7, 8, 9], [6, 9, 10]);
    checkCompareAttributesEqual(c, [5, undefined, 5], [4, 3, 4]);
  });

  test('checkMemoryColumn_compareMultipleAttributes_max', function() {
    var c = new MemoryColumn('test_column', 'ms', fieldGetter('x'),
        AggregationMode.MAX);

    // At least one attribute has multiple values.
    checkCompareAttributesEqual(c, [0, 1, 3], [1, 3, 2]);
    checkCompareAttributesLess(c, ['4', undefined, '4'], ['3', '4', '5']);
    checkCompareAttributesLess(c, [3, 3, 3], [9, undefined, 10]);

    // Both attributes have single values.
    checkCompareAttributesEqual(c,
        [undefined, 'ttt', undefined], ['ttt', 'ttt', undefined]);
    checkCompareAttributesLess(c, [undefined, -1, undefined], [-2, -2, -2]);
    checkCompareAttributesLess(c, ['Q', 'Q', undefined], ['X', undefined, 'X']);
  });

  test('checkMemoryColumn_cmp', function() {
    var c = new MemoryColumn('test_column', 'ms', fieldGetter('x'),
        AggregationMode.DIFF);

    // Cell (or the associated attribute) undefined in one or both rows.
    assert.equal(c.cmp({}, {y: new MemoryCell([undefined])}), 0);
    assert.equal(c.cmp({x: new MemoryCell(undefined)}, {}), 0);
    assert.equal(c.cmp({x: new MemoryCell([undefined, undefined])}, {}), 0);
    assert.isAbove(c.cmp({x: buildStringCell('ms', ['negative'])}, {}), 0);
    assert.isAbove(c.cmp({x: buildStringCell('ms', ['negative'])},
        {x: new MemoryCell([undefined])}), 0);
    assert.isBelow(c.cmp({}, {x: buildStringCell('ms', ['positive'])}), 0);
    assert.isBelow(c.cmp({x: new MemoryCell(undefined)},
        {x: buildStringCell('ms', ['positive'])}), 0);

    // Single attribute.
    assert.equal(c.cmp({x: buildStringCell('t', ['equal'])},
        {x: buildStringCell('t', ['equal'])}), 0);
    assert.isAbove(c.cmp({x: buildStringCell('u', ['bigger'])},
        {x: buildStringCell('u', ['BIG'])}), 0);
    assert.isBelow(c.cmp({x: buildStringCell('v', ['small'])},
        {x: buildStringCell('v', ['smaLL'])}), 0);

    // Multiple attributes.
    assert.isBelow(c.cmp(
        {x: buildStringCell('', ['MemoryColumn', 'supports*', undefined])},
        {x: buildStringCell('', ['comparing', 'multiple', 'values :-)'])}), 0);
  });

  test('checkMemoryColumn_getInfos', function() {
    var c = new MemoryColumn('test_column', 'ms', fieldGetter('x'),
        AggregationMode.MAX);

    var info = new AttributeInfo(AttributeInfoType.INFORMATION, 'interesting');
    var warning = new AttributeInfo(AttributeInfoType.WARNING, 'thrilling');
    var error = new AttributeInfo(AttributeInfoType.ERROR, 'inconceivable');

    var attr1 = new ScalarAttribute('bytes', 64);
    attr1.infos.push(info);
    attr1.infos.push(warning);
    var attr2 = new ScalarAttribute('bytes', 128);
    var attr3 = new ScalarAttribute('bytes', 256);
    attr3.infos.push(error);

    assert.deepEqual(c.getInfos([attr1]), [info, warning]);
    assert.deepEqual(c.getInfos([attr1, attr2]), []);
    assert.deepEqual(c.getInfos([attr1, attr2, attr3]), []);
  });

  test('checkMemoryColumn_getImportance', function() {
    var c = new ScalarMemoryColumn('test_column', 'bytes', fieldGetter('x'));

    var rules1 = [];
    assert.equal(c.getImportance(rules1), 0);

    var rules2 = [
      {
        condition: 'test',
        importance: 4
      },
      {
        condition: /test$/,
        importance: 2
      }
    ];
    assert.equal(c.getImportance(rules2), 1);

    var rules3 = [
      {
        condition: 'test_column',
        importance: 10
      },
      {
        importance: 5
      }
    ];
    assert.equal(c.getImportance(rules3), 10);

    var rules4 = [
      {
        condition: 'test_column2',
        importance: 8
      },
      {
        condition: /column/,
        importance: 12
      }
    ];
    assert.equal(c.getImportance(rules4), 12);
  });

  test('checkMemoryColumn_nameMatchesCondition', function() {
    var c = new ScalarMemoryColumn('test_column', 'bytes', fieldGetter('x'));

    assert.isTrue(MemoryColumn.nameMatchesCondition('test_column', undefined));

    assert.isFalse(MemoryColumn.nameMatchesCondition('test_column', 'test'));
    assert.isTrue(
        MemoryColumn.nameMatchesCondition('test_column', 'test_column'));
    assert.isFalse(
        MemoryColumn.nameMatchesCondition('test_column', 'test_column2'));

    assert.isTrue(MemoryColumn.nameMatchesCondition('test_column', /test/));
    assert.isTrue(
        MemoryColumn.nameMatchesCondition('test_column', /^[^_]*_[^_]*$/));
    assert.isFalse(MemoryColumn.nameMatchesCondition('test_column', /test$/));
  });

  test('checkScalarMemoryColumn_value', function() {
    var c = new ScalarMemoryColumn('test_column', 'bytes', fieldGetter('x'),
        AggregationMode.DIFF);
    c.color = '#009999';

    // Undefined attribute values.
    var cell = buildScalarCell('bytes', [undefined, 1, undefined]);
    var value = c.value({x: cell});
    assert.equal(value, '');

    // Single attribute value.
    var cell = buildScalarCell('bytes', [5.4975581e13 /* 50 TiB */]);
    cell.attrs[0].infos = [
      new AttributeInfo(AttributeInfoType.WARNING, 'This value is too cool'),
      new AttributeInfo(AttributeInfoType.LINK, 'Source: Test')
    ];
    var value = c.value({x: cell});
    assert.lengthOf(value.childNodes, 3);
    assert.equal(value.style.color, 'rgb(0, 153, 153)');
    assert.equal(value.childNodes[0].tagName, 'TR-UI-U-SCALAR-SPAN');
    assert.equal(value.childNodes[0].value, 5.4975581e13);
    assert.equal(value.childNodes[0].unit, tr.b.u.Units.sizeInBytes);
    assert.equal(value.childNodes[1].textContent, String.fromCharCode(9888));
    assert.equal(value.childNodes[1].title, 'This value is too cool');
    assert.equal(value.childNodes[2].textContent, String.fromCharCode(9903));
    assert.equal(value.childNodes[2].title, 'Source: Test');
    this.addHTMLOutput(value);

    // Multiple attribute values.
    var cell = buildScalarCell('bytes',
        [5.4975581e13 /* 50 TiB */, undefined, 2.1990233e13 /* 20 TiB */]);
    cell.attrs[0].infos = [
      new AttributeInfo(AttributeInfoType.ERROR, 'This info is invisible')
    ];
    var value = c.value({x: cell});
    assert.lengthOf(value.childNodes, 1);
    assert.equal(value.style.color, 'rgb(0, 153, 153)');
    assert.lengthOf(value.childNodes[0].childNodes, 1);
    assert.equal(value.childNodes[0].style.color, 'green');
    assert.equal(value.childNodes[0].childNodes[0].tagName,
        'TR-UI-U-SCALAR-SPAN');
    assert.equal(value.childNodes[0].childNodes[0].value, -3.2985348e13);
    assert.equal(value.childNodes[0].childNodes[0].unit,
        tr.b.u.Units.sizeInBytes);
    assert.equal(value.childNodes[0].childNodes[0].isDelta, true);
    this.addHTMLOutput(value);
  });

  test('checkScalarMemoryColumn_formatSingleAttributeValue', function() {
    var c = new ScalarMemoryColumn('non_bytes_column', 'ms', fieldGetter('x'),
        undefined /* aggregation mode */);
    var value = c.formatSingleAttributeValue(new ScalarAttribute('ms', 123));
    assert.equal(value.tagName, 'TR-UI-U-SCALAR-SPAN');
    assert.equal(value.value, 123);
    assert.equal(value.unit, tr.b.u.Units.unitlessNumber);
    this.addHTMLOutput(value);

    var c = new ScalarMemoryColumn('bytes_column', 'bytes', fieldGetter('x'),
        undefined /* aggregation mode */);
    var value = c.formatSingleAttributeValue(new ScalarAttribute('bytes', 456));
    assert.equal(value.tagName, 'TR-UI-U-SCALAR-SPAN');
    assert.equal(value.value, 456);
    assert.equal(value.unit, tr.b.u.Units.sizeInBytes);
    this.addHTMLOutput(value);
  });

  test('checkScalarMemoryColumn_formatMultipleAttributeValues_diff',
      function() {
    var c = new ScalarMemoryColumn('non_bytes_column', 'ms', fieldGetter('x'),
        AggregationMode.DIFF);
    checkScalarMemoryColumnValueFormat(this, c, [1, 2, 3], 2,
        tr.b.u.Units.unitlessNumber, true, 'red');
    checkScalarMemoryColumnValueFormat(this, c, [10, undefined], -10,
        tr.b.u.Units.unitlessNumber, true, 'green');
    checkScalarMemoryColumnValueFormat(this, c, [undefined, 60, 0], 0,
        tr.b.u.Units.unitlessNumber, true);

    var c = new ScalarMemoryColumn('bytes_column', 'bytes', fieldGetter('x'),
        AggregationMode.DIFF);
    checkScalarMemoryColumnValueFormat(this, c, [1, 2, 3], 2,
        tr.b.u.Units.sizeInBytes, true, 'red');
    checkScalarMemoryColumnValueFormat(this, c, [10, undefined], -10,
        tr.b.u.Units.sizeInBytes, true, 'green');
    checkScalarMemoryColumnValueFormat(this, c, [undefined, 60, 0], 0,
        tr.b.u.Units.sizeInBytes, true, undefined);
  });

  test('checkScalarMemoryColumn_formatMultipleAttributeValues_max',
      function() {
    var c = new ScalarMemoryColumn('non_bytes_column', 'ms', fieldGetter('x'),
        AggregationMode.MAX);
    checkScalarMemoryColumnValueFormat(this, c, [1, 2, 3], 3,
        tr.b.u.Units.unitlessNumber, false);
    checkScalarMemoryColumnValueFormat(this, c, [10, undefined], 10,
        tr.b.u.Units.unitlessNumber, false);
    checkScalarMemoryColumnValueFormat(this, c, [undefined, 60, 0], 60,
        tr.b.u.Units.unitlessNumber, false);
    checkScalarMemoryColumnValueFormat(this, c,
        [undefined, 10, 20, undefined], 20, tr.b.u.Units.unitlessNumber, false);

    var c = new ScalarMemoryColumn('bytes_column', 'bytes', fieldGetter('x'),
        AggregationMode.MAX);
    checkScalarMemoryColumnValueFormat(this, c, [1, 2, 3], 3,
        tr.b.u.Units.sizeInBytes, false);
    checkScalarMemoryColumnValueFormat(this, c, [10, undefined], 10,
        tr.b.u.Units.sizeInBytes, false);
    checkScalarMemoryColumnValueFormat(this, c, [undefined, 60, 0], 60,
        tr.b.u.Units.sizeInBytes, false);
    checkScalarMemoryColumnValueFormat(this, c,
        [undefined, 10, 20, undefined], 20, tr.b.u.Units.sizeInBytes, false);
  });

  test('checkScalarMemoryColumn_cmp', function() {
    var c = new ScalarMemoryColumn('test_column', 'bytes', fieldGetter('x'),
        AggregationMode.DIFF);

    // Undefined attribute values.
    assert.isAbove(c.cmp({x: buildScalarCell('bytes', [-9999999999])},
        {x: undefined}), 0);
    assert.isBelow(c.cmp({x: new MemoryCell(undefined)},
        {x: buildScalarCell('bytes', [748, 749])}), 0);
    assert.equal(c.cmp({},
        {x: buildScalarCell('bytes', [undefined, undefined])}), 0);

    // Single attribute value.
    assert.isBelow(c.cmp({x: buildScalarCell('bytes', [16384])},
        {x: buildScalarCell('bytes', [32768])}), 0);

    // Multiple attribute values.
    assert.equal(c.cmp({x: buildScalarCell('bytes', [999, undefined, 1001])},
        {x: buildScalarCell('bytes', [undefined, 5, 2])}), 0);
  });

  test('checkScalarMemoryColumn_compareSingleAttributes', function() {
    var c = new ScalarMemoryColumn('test_column', 'ms', fieldGetter('x'),
        undefined /* aggregation mode */);

    assert.isBelow(c.compareSingleAttributes(new ScalarAttribute('ms', 99),
        new ScalarAttribute('ms', 100)), 0);
    assert.equal(c.compareSingleAttributes(new ScalarAttribute('', 0xEEE),
        new ScalarAttribute('', 0xEEE)), 0);
    assert.isAbove(c.compareSingleAttributes(new ScalarAttribute('bytes', 10),
        new ScalarAttribute('bytes', 2)), 0);
  });

  test('checkScalarMemoryColumn_compareMultipleAttributes_diff', function() {
    var c = new ScalarMemoryColumn('test_column', 'ms', fieldGetter('x'),
        AggregationMode.DIFF);

    assert.isBelow(c.compareMultipleAttributes(
        buildScalarCell('bytes', [10000, 10001, 10002] /* diff +2 */).attrs,
        buildScalarCell('bytes', [5, 7, 8] /* diff +3 */).attrs), 0);
    assert.equal(c.compareMultipleAttributes(
        buildScalarCell('ms', [4, undefined] /* diff -4 */).attrs,
        buildScalarCell('ms', [999, 995] /* diff -4 */).attrs), 0);
    assert.isAbove(c.compareMultipleAttributes(
        buildScalarCell('bytes', [10, undefined, 12] /* diff +2 */).attrs,
        buildScalarCell('bytes', [11, 50, 12] /* diff +1 */).attrs), 0);
    assert.equal(c.compareMultipleAttributes(
        buildScalarCell('W', [17, undefined, 17] /* diff 0 */).attrs,
        buildScalarCell('W',
            [undefined, 100, undefined] /* diff 0 */).attrs), 0);
  });

  test('checkScalarMemoryColumn_compareMultipleAttributes_max', function() {
    var c = new ScalarMemoryColumn('test_column', 'ms', fieldGetter('x'),
        AggregationMode.MAX);

    assert.isBelow(c.compareMultipleAttributes(
        buildScalarCell('bytes', [10, undefined, 12]).attrs,
        buildScalarCell('bytes', [11, 50, 12]).attrs), 0);
    assert.equal(c.compareMultipleAttributes(
        buildScalarCell('ms', [999, undefined, -8888]).attrs,
        buildScalarCell('ms', [undefined, 999, undefined]).attrs), 0);
    assert.isAbove(c.compareMultipleAttributes(
        buildScalarCell('bytes', [10000, 10001, 10002]).attrs,
        buildScalarCell('bytes', [5, 7, 8]).attrs), 0);
    assert.isBelow(c.compareMultipleAttributes(
        buildScalarCell('W', [17, undefined, 17]).attrs,
        buildScalarCell('W', [undefined, 100, undefined]).attrs), 0);
  });

  test('checkFieldGetter', function() {
    // Zero cells.
    var f = fieldGetter();
    var row = {a: 5};
    assert.equal(f(row), row);

    // One cell.
    var f = fieldGetter('p2');
    assert.equal(f({p1: 'wrong', p2: 'right'}), 'right');
    assert.isUndefined(f({p1: 'wrong'}));

    // Multiple cells.
    var f = fieldGetter('b', 'd', 'f');
    assert.equal(f({a: 0, b: {c: 0, d: {e: 0, f: 42}}}), 42);
  });

  test('checkExpandTableRowsRecursively', function() {
    var columns = [
      {
        title: 'Single column',
        value: function(row) { return row.data; },
        width: '100px'
      }
    ];

    var rows = [
      {
        data: 'allocated',
        subRows: [
          {
            data: 'v8'
          },
          {
            data: 'oilpan',
            subRows: [
              { data: 'heaps' },
              { data: 'objects' }
            ]
          },
          {
            data: 'skia',
            subRows: [
              { data: 'way' },
              { data: 'too' },
              { data: 'many' },
              { data: 'sub-' },
              { data: 'rows' },
              { data: 'so' },
              { data: 'that' },
              { data: 'they' },
              { data: 'wouldn\'t' },
              { data: 'be' },
              { data: 'auto-' },
              { data: 'expanded' }
            ]
          }
        ]
      },
      {
        data: 'overhead',
        subRows: [
          {
            data: 'internal_fragmentation'
          },
          {
            data: 'external_fragmentation',
            subRows: []
          }
        ]
      }
    ];

    var table = document.createElement('tr-ui-b-table');
    table.tableColumns = columns;
    table.tableRows = rows;
    table.rebuild();

    expandTableRowsRecursively(table);

    // 'allocated' row should be expanded.
    assert.isTrue(table.getExpandedForTableRow(rows[0]));

    // 'allocated/v8' row cannot be expanded (no sub-rows).
    assert.isFalse(table.getExpandedForTableRow(rows[0].subRows[0]));

    // 'allocated/oilpan' row should be expanded.
    assert.isTrue(table.getExpandedForTableRow(rows[0].subRows[1]));

    // 'allocated/skia' row should not be expanded (more than 10 sub-rows).
    assert.isFalse(table.getExpandedForTableRow(rows[0].subRows[2]));

    // 'overhead' row should be expanded.
    assert.isTrue(table.getExpandedForTableRow(rows[1]));

    // 'overhead/internal_fragmentation' cannot be expanded (no sub-rows).
    assert.isFalse(table.getExpandedForTableRow(rows[1].subRows[0]));

    // 'overhead/external_fragmentation' cannot be expanded (no sub-rows).
    assert.isFalse(table.getExpandedForTableRow(rows[1].subRows[1]));
  });

  test('checkMemoryCell_extractAttributes', function() {
    assert.isUndefined(MemoryCell.extractAttributes(undefined));

    assert.isUndefined(MemoryCell.extractAttributes(new MemoryCell(undefined)));

    var attrs = [new ScalarAttribute('bytes', 1024)];
    assert.strictEqual(
        MemoryCell.extractAttributes(new MemoryCell(attrs)), attrs);
  });

  test('checkAggregateTableRowCellsRecursively', function() {
    var row = {
      testCells: {
        a: buildScalarCell('bytes', [17])
      },
      subRows: [
        {
          // Intentionally no testCells.
          subRows: [
            {
              testCells: {
                b: buildScalarCell('bytes', [103]),
                c: buildStringCell('', ['should-not-propagate-upwards'])
              }
              // Intentionally no subRows.
            },
            {
              testCells: {},
              subRows: []
            }
          ]
        },
        {
          testCells: {
            b: buildScalarCell('bytes', [20]),
            a: buildScalarCell('bytes', [13])
          }
        }
      ]
    };

    aggregateTableRowCellsRecursively(row, 'testCells');

    var mockColumn = new MemoryColumn('', '', tr.b.identity, undefined);

    checkSizeAttributes(row.testCells.a, mockColumn, [17]);
    checkSizeAttributes(row.testCells.b, mockColumn, [123]);
    checkAttributes(row.testCells.c, mockColumn, [undefined]);
  });

  test('checkAggregateTableRowCells', function() {
    var cell = new MemoryCell(undefined);
    cell.foo = 'bar';

    var row = {
      // Intentionally no testCells.
      otherCells: {
        a: cell
      }
    };
    var subRows = [
      {
        testCells: {
          a: buildScalarCell('bytes', [1, 9])
        },
        subRows: [
          {
            testCells: {
              c: buildScalarCell('bytes', [13])
            }
          }
        ]
      },
      {
        testCells: {
          a: buildScalarCell('bytes', [2, 17]),
          b: buildScalarCell('bytes', [5])
        },
        otherCells: {
          a: buildScalarCell('objects', [153]),
          b: buildStringCell('', ['attribute-should-not-propagate-upwards', ''])
        }
      }
    ];

    aggregateTableRowCells(row, subRows, 'testCells');
    aggregateTableRowCells(row, subRows, 'otherCells');

    var mockColumn = new MemoryColumn('', '', tr.b.identity, undefined);

    checkSizeAttributes(row.testCells.a, mockColumn, [3, 26]);
    checkSizeAttributes(row.testCells.b, mockColumn, [5]);
    assert.notProperty(row.testCells, 'c');

    var otherCellA = row.otherCells.a;
    assert.equal(otherCellA.foo, 'bar');
    checkAttributes(otherCellA, mockColumn, [153], ScalarAttribute, 'objects');
    checkAttributes(row.otherCells.b, mockColumn, [undefined, undefined]);
  });

  test('checkCreateCells', function() {
    var values = [
      {
        a: 9,
        b: 314
      },
      {
        b: 159,
        c: undefined
      },
      undefined,
      {
        b: 265,
        d: 0
      }
    ];

    var mockColumn = new MemoryColumn('', '', tr.b.identity, undefined);

    // Without callback.
    var cells = createCells(values, function(dict) {
      var attrs = {};
      tr.b.iterItems(dict, function(key, value) {
        addAttributeIfDefined(attrs, key, ScalarAttribute, 'bytes', value);
      });
      return attrs;
    });
    assert.deepEqual(Object.keys(cells), ['a', 'b', 'd']);
    checkSizeAttributes(
        cells.a, mockColumn, [9, undefined, undefined, undefined]);
    checkSizeAttributes(cells.b, mockColumn, [314, 159, undefined, 265]);
    checkSizeAttributes(
        cells.d, mockColumn, [undefined, undefined, undefined, 0]);

    // With callback.
    var createdAttrNames = {};
    var cells = createCells(values,
        function(dict) {
          var attrs = {};
          tr.b.iterItems(dict, function(key, value) {
            addAttributeIfDefined(attrs, key, ScalarAttribute, 'bytes', value);
          });
          return attrs;
        },
        function(attrName, cell) {
          assert.lengthOf(cell.attrs, 4);
          assert.notProperty(createdAttrNames, attrName);
          createdAttrNames[attrName] = true;
        });
    assert.sameMembers(Object.keys(createdAttrNames), ['a', 'b', 'd']);
  });

  test('checkAddAttributeIfDefined', function() {
    var attrs = {};

    // Undefined attribute value.
    addAttributeIfDefined(attrs, 'x', ScalarAttribute, 'bytes', undefined);
    assert.lengthOf(Object.keys(attrs), 0);

    // Defined attribute value.
    addAttributeIfDefined(attrs, 'x', ScalarAttribute, 'bytes', 16384);
    assert.deepEqual(Object.keys(attrs), ['x']);
    checkSizeAttributes([attrs.x], undefined /* no column */, [16384]);

    var didFireCallback;
    var addedCallback = function(attr) {
      didFireCallback = true;
    };

    // Undefined attribute value with callback.
    didFireCallback = false;
    addAttributeIfDefined(
        attrs, 'y', StringAttribute, '', undefined, addedCallback);
    assert.isFalse(didFireCallback);
    assert.deepEqual(Object.keys(attrs), ['x']);

    // Defined attribute with callback.
    didFireCallback = false;
    addAttributeIfDefined(
        attrs, 'y', StringAttribute, '', '(+infinity)', addedCallback);
    assert.isTrue(didFireCallback);
    assert.deepEqual(Object.keys(attrs), ['x', 'y']);
    checkAttributes([attrs.y], undefined /* no column */, ['(+infinity)'],
        StringAttribute, '');
  });
});
</script>
